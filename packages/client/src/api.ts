/* tslint:disable */
/* eslint-disable */
/**
 * @algotia/server-2
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Balance
 */
export interface Balance {
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    free: number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    used: number;
    /**
     * 
     * @type {number}
     * @memberof Balance
     */
    total: number;
}
/**
 * 
 * @export
 * @interface CreateBacktestOptions
 */
export interface CreateBacktestOptions {
    /**
     * 
     * @type {string}
     * @memberof CreateBacktestOptions
     */
    strategyPath: string;
    /**
     * 
     * @type {ExchangeID}
     * @memberof CreateBacktestOptions
     */
    exchange: ExchangeID;
    /**
     * 
     * @type {string}
     * @memberof CreateBacktestOptions
     */
    period: string;
    /**
     * 
     * @type {string}
     * @memberof CreateBacktestOptions
     */
    pair: string;
    /**
     * 
     * @type {number}
     * @memberof CreateBacktestOptions
     */
    from: number;
    /**
     * 
     * @type {number}
     * @memberof CreateBacktestOptions
     */
    to: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof CreateBacktestOptions
     */
    initialBalance: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface CreateBacktestResult
 */
export interface CreateBacktestResult {
    /**
     * 
     * @type {PickSimulatedExchangeStoreExcludeKeyofSimulatedExchangeStoreCurrentTimeOrCurrentPrice}
     * @memberof CreateBacktestResult
     */
    results: PickSimulatedExchangeStoreExcludeKeyofSimulatedExchangeStoreCurrentTimeOrCurrentPrice;
    /**
     * 
     * @type {Array<OHLCVCandle>}
     * @memberof CreateBacktestResult
     */
    candles: Array<OHLCVCandle>;
}
/**
 * 
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Currency
     */
    code: string;
    /**
     * 
     * @type {number}
     * @memberof Currency
     */
    numericId?: number;
    /**
     * 
     * @type {number}
     * @memberof Currency
     */
    precision: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum ExchangeID {
    Binance = 'binance',
    Kucoin = 'kucoin',
    Bitfinex = 'bitfinex'
}

/**
 * 
 * @export
 * @interface Fee
 */
export interface Fee {
    /**
     * 
     * @type {string}
     * @memberof Fee
     */
    type: FeeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Fee
     */
    currency: string;
    /**
     * 
     * @type {number}
     * @memberof Fee
     */
    rate: number;
    /**
     * 
     * @type {number}
     * @memberof Fee
     */
    cost: number;
}

/**
    * @export
    * @enum {string}
    */
export enum FeeTypeEnum {
    Taker = 'taker',
    Maker = 'maker'
}

/**
 * 
 * @export
 * @interface GetStrategyResult
 */
export interface GetStrategyResult {
    /**
     * 
     * @type {string}
     * @memberof GetStrategyResult
     */
    value: string;
    /**
     * 
     * @type {StrategyMetaData}
     * @memberof GetStrategyResult
     */
    meta: StrategyMetaData;
}
/**
 * 
 * @export
 * @interface Market
 */
export interface Market {
    /**
     * 
     * @type {string}
     * @memberof Market
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Market
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof Market
     */
    base: string;
    /**
     * 
     * @type {string}
     * @memberof Market
     */
    quote: string;
    /**
     * 
     * @type {string}
     * @memberof Market
     */
    baseId: string;
    /**
     * 
     * @type {string}
     * @memberof Market
     */
    quoteId: string;
    /**
     * 
     * @type {string}
     * @memberof Market
     */
    type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Market
     */
    spot?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Market
     */
    margin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Market
     */
    swap?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Market
     */
    future?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Market
     */
    active: boolean;
    /**
     * 
     * @type {MarketPrecision}
     * @memberof Market
     */
    precision: MarketPrecision;
    /**
     * 
     * @type {MarketLimits}
     * @memberof Market
     */
    limits: MarketLimits;
    /**
     * 
     * @type {boolean}
     * @memberof Market
     */
    tierBased: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Market
     */
    percentage: boolean;
    /**
     * 
     * @type {number}
     * @memberof Market
     */
    taker: number;
    /**
     * 
     * @type {number}
     * @memberof Market
     */
    maker: number;
    /**
     * 
     * @type {any}
     * @memberof Market
     */
    info: any | null;
}
/**
 * 
 * @export
 * @interface MarketLimits
 */
export interface MarketLimits {
    /**
     * 
     * @type {MinMax}
     * @memberof MarketLimits
     */
    cost?: MinMax;
    /**
     * 
     * @type {MinMax}
     * @memberof MarketLimits
     */
    price: MinMax;
    /**
     * 
     * @type {MinMax}
     * @memberof MarketLimits
     */
    amount: MinMax;
}
/**
 * 
 * @export
 * @interface MarketPrecision
 */
export interface MarketPrecision {
    /**
     * 
     * @type {number}
     * @memberof MarketPrecision
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof MarketPrecision
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof MarketPrecision
     */
    quote: number;
    /**
     * 
     * @type {number}
     * @memberof MarketPrecision
     */
    base: number;
}
/**
 * 
 * @export
 * @interface MinMax
 */
export interface MinMax {
    /**
     * 
     * @type {number}
     * @memberof MinMax
     */
    min: number;
    /**
     * 
     * @type {number}
     * @memberof MinMax
     */
    max: number | null;
}
/**
 * 
 * @export
 * @interface OHLCVCandle
 */
export interface OHLCVCandle {
    /**
     * 
     * @type {number}
     * @memberof OHLCVCandle
     */
    timestamp: number;
    /**
     * 
     * @type {number}
     * @memberof OHLCVCandle
     */
    open: number;
    /**
     * 
     * @type {number}
     * @memberof OHLCVCandle
     */
    high: number;
    /**
     * 
     * @type {number}
     * @memberof OHLCVCandle
     */
    low: number;
    /**
     * 
     * @type {number}
     * @memberof OHLCVCandle
     */
    close: number;
    /**
     * 
     * @type {number}
     * @memberof OHLCVCandle
     */
    volume: number;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    clientOrderId: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    datetime: string;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    timestamp: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    lastTradeTimestamp: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    status: OrderStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    type: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    timeInForce?: string;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    side: OrderSideEnum;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    average?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    amount: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    filled: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    remaining: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    cost: number;
    /**
     * 
     * @type {Array<Trade>}
     * @memberof Order
     */
    trades: Array<Trade>;
    /**
     * 
     * @type {Fee}
     * @memberof Order
     */
    fee: Fee;
    /**
     * 
     * @type {any}
     * @memberof Order
     */
    info: any | null;
}

/**
    * @export
    * @enum {string}
    */
export enum OrderStatusEnum {
    Open = 'open',
    Closed = 'closed',
    Canceled = 'canceled'
}
/**
    * @export
    * @enum {string}
    */
export enum OrderSideEnum {
    Buy = 'buy',
    Sell = 'sell'
}

/**
 * From T, pick a set of properties whose keys are in the union K
 * @export
 * @interface PickSimulatedExchangeStoreExcludeKeyofSimulatedExchangeStoreCurrentTimeOrCurrentPrice
 */
export interface PickSimulatedExchangeStoreExcludeKeyofSimulatedExchangeStoreCurrentTimeOrCurrentPrice {
    /**
     * 
     * @type {{ [key: string]: Balance; }}
     * @memberof PickSimulatedExchangeStoreExcludeKeyofSimulatedExchangeStoreCurrentTimeOrCurrentPrice
     */
    balance: { [key: string]: Balance; };
    /**
     * 
     * @type {Array<Order>}
     * @memberof PickSimulatedExchangeStoreExcludeKeyofSimulatedExchangeStoreCurrentTimeOrCurrentPrice
     */
    openOrders: Array<Order>;
    /**
     * 
     * @type {Array<Order>}
     * @memberof PickSimulatedExchangeStoreExcludeKeyofSimulatedExchangeStoreCurrentTimeOrCurrentPrice
     */
    closedOrders: Array<Order>;
    /**
     * 
     * @type {Array<StrategyError>}
     * @memberof PickSimulatedExchangeStoreExcludeKeyofSimulatedExchangeStoreCurrentTimeOrCurrentPrice
     */
    errors: Array<StrategyError>;
}
/**
 * Construct a type with a set of properties K of type T
 * @export
 * @interface RecordExchangeIDBoolean
 */
export interface RecordExchangeIDBoolean {
    /**
     * 
     * @type {boolean}
     * @memberof RecordExchangeIDBoolean
     */
    binance?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecordExchangeIDBoolean
     */
    kucoin?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RecordExchangeIDBoolean
     */
    bitfinex?: boolean;
}
/**
 * 
 * @export
 * @interface StrategyError
 */
export interface StrategyError {
    /**
     * 
     * @type {number}
     * @memberof StrategyError
     */
    timestamp: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyError
     */
    message: string;
    /**
     * 
     * @type {{ [key: string]: Balance; }}
     * @memberof StrategyError
     */
    balance: { [key: string]: Balance; };
}
/**
 * 
 * @export
 * @interface StrategyMetaData
 */
export interface StrategyMetaData {
    /**
     * 
     * @type {number}
     * @memberof StrategyMetaData
     */
    modifiedAt: number;
    /**
     * 
     * @type {string}
     * @memberof StrategyMetaData
     */
    basename: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyMetaData
     */
    path: string;
    /**
     * 
     * @type {string}
     * @memberof StrategyMetaData
     */
    language: StrategyMetaDataLanguageEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum StrategyMetaDataLanguageEnum {
    JavaScript = 'JavaScript',
    TypeScript = 'TypeScript'
}

/**
 * 
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    datetime: string;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    id: string;
    /**
     * 
     * @type {any}
     * @memberof Trade
     */
    info: any | null;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    order?: string;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    price: number;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    timestamp: number;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    side: TradeSideEnum;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    symbol: string;
    /**
     * 
     * @type {string}
     * @memberof Trade
     */
    takerOrMaker: TradeTakerOrMakerEnum;
    /**
     * 
     * @type {number}
     * @memberof Trade
     */
    cost: number;
    /**
     * 
     * @type {Fee}
     * @memberof Trade
     */
    fee: Fee;
}

/**
    * @export
    * @enum {string}
    */
export enum TradeSideEnum {
    Buy = 'buy',
    Sell = 'sell'
}
/**
    * @export
    * @enum {string}
    */
export enum TradeTakerOrMakerEnum {
    Taker = 'taker',
    Maker = 'maker'
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateBacktestOptions} createBacktestOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBacktest: async (createBacktestOptions: CreateBacktestOptions, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBacktestOptions' is not null or undefined
            if (createBacktestOptions === null || createBacktestOptions === undefined) {
                throw new RequiredError('createBacktestOptions','Required parameter createBacktestOptions was null or undefined when calling createBacktest.');
            }
            const localVarPath = `/backtest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof createBacktestOptions !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(createBacktestOptions !== undefined ? createBacktestOptions : {})
                : (createBacktestOptions || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConfigOptions: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStrategyMetaData: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/strategy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {'port' | 'appDir'} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigOptionByKey: async (key: 'port' | 'appDir', options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getConfigOptionByKey.');
            }
            const localVarPath = `/config/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies: async (id: ExchangeID, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCurrencies.');
            }
            const localVarPath = `/exchange/{id}/currencies`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeIds: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchange/ids`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatuses: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/exchange/statuses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {string} pair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket: async (id: ExchangeID, pair: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getMarket.');
            }
            // verify required parameter 'pair' is not null or undefined
            if (pair === null || pair === undefined) {
                throw new RequiredError('pair','Required parameter pair was null or undefined when calling getMarket.');
            }
            const localVarPath = `/exchange/{id}/market`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pair !== undefined) {
                localVarQueryParameter['pair'] = pair;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPairs: async (id: ExchangeID, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getPairs.');
            }
            const localVarPath = `/exchange/{id}/pairs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyByFilename: async (fileName: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            if (fileName === null || fileName === undefined) {
                throw new RequiredError('fileName','Required parameter fileName was null or undefined when calling getStrategyByFilename.');
            }
            const localVarPath = `/strategy/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeFrames: async (id: ExchangeID, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTimeFrames.');
            }
            const localVarPath = `/exchange/{id}/timeframes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateBacktestOptions} createBacktestOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBacktest(createBacktestOptions: CreateBacktestOptions, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateBacktestResult>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).createBacktest(createBacktestOptions, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllConfigOptions(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getAllConfigOptions(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllStrategyMetaData(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StrategyMetaData>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getAllStrategyMetaData(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {'port' | 'appDir'} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigOptionByKey(key: 'port' | 'appDir', options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string | number>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getConfigOptionByKey(key, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrencies(id: ExchangeID, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Currency; }>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getCurrencies(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeIds(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getExchangeIds(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeStatuses(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordExchangeIDBoolean>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getExchangeStatuses(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {string} pair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarket(id: ExchangeID, pair: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Market>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getMarket(id, pair, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPairs(id: ExchangeID, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getPairs(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStrategyByFilename(fileName: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetStrategyResult>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getStrategyByFilename(fileName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTimeFrames(id: ExchangeID, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number | string; }>> {
            const localVarAxiosArgs = await DefaultApiAxiosParamCreator(configuration).getTimeFrames(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {CreateBacktestOptions} createBacktestOptions 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBacktest(createBacktestOptions: CreateBacktestOptions, options?: any): AxiosPromise<CreateBacktestResult> {
            return DefaultApiFp(configuration).createBacktest(createBacktestOptions, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllConfigOptions(options?: any): AxiosPromise<any> {
            return DefaultApiFp(configuration).getAllConfigOptions(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllStrategyMetaData(options?: any): AxiosPromise<Array<StrategyMetaData>> {
            return DefaultApiFp(configuration).getAllStrategyMetaData(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {'port' | 'appDir'} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigOptionByKey(key: 'port' | 'appDir', options?: any): AxiosPromise<string | number> {
            return DefaultApiFp(configuration).getConfigOptionByKey(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencies(id: ExchangeID, options?: any): AxiosPromise<{ [key: string]: Currency; }> {
            return DefaultApiFp(configuration).getCurrencies(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeIds(options?: any): AxiosPromise<Array<string>> {
            return DefaultApiFp(configuration).getExchangeIds(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatuses(options?: any): AxiosPromise<RecordExchangeIDBoolean> {
            return DefaultApiFp(configuration).getExchangeStatuses(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {string} pair 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarket(id: ExchangeID, pair: string, options?: any): AxiosPromise<Market> {
            return DefaultApiFp(configuration).getMarket(id, pair, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPairs(id: ExchangeID, options?: any): AxiosPromise<Array<string>> {
            return DefaultApiFp(configuration).getPairs(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStrategyByFilename(fileName: string, options?: any): AxiosPromise<GetStrategyResult> {
            return DefaultApiFp(configuration).getStrategyByFilename(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExchangeID} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTimeFrames(id: ExchangeID, options?: any): AxiosPromise<{ [key: string]: number | string; }> {
            return DefaultApiFp(configuration).getTimeFrames(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {CreateBacktestOptions} createBacktestOptions 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createBacktest(createBacktestOptions: CreateBacktestOptions, options?: any) {
        return DefaultApiFp(this.configuration).createBacktest(createBacktestOptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllConfigOptions(options?: any) {
        return DefaultApiFp(this.configuration).getAllConfigOptions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAllStrategyMetaData(options?: any) {
        return DefaultApiFp(this.configuration).getAllStrategyMetaData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {'port' | 'appDir'} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfigOptionByKey(key: 'port' | 'appDir', options?: any) {
        return DefaultApiFp(this.configuration).getConfigOptionByKey(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExchangeID} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrencies(id: ExchangeID, options?: any) {
        return DefaultApiFp(this.configuration).getCurrencies(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExchangeIds(options?: any) {
        return DefaultApiFp(this.configuration).getExchangeIds(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExchangeStatuses(options?: any) {
        return DefaultApiFp(this.configuration).getExchangeStatuses(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExchangeID} id 
     * @param {string} pair 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getMarket(id: ExchangeID, pair: string, options?: any) {
        return DefaultApiFp(this.configuration).getMarket(id, pair, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExchangeID} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPairs(id: ExchangeID, options?: any) {
        return DefaultApiFp(this.configuration).getPairs(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getStrategyByFilename(fileName: string, options?: any) {
        return DefaultApiFp(this.configuration).getStrategyByFilename(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExchangeID} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTimeFrames(id: ExchangeID, options?: any) {
        return DefaultApiFp(this.configuration).getTimeFrames(id, options).then((request) => request(this.axios, this.basePath));
    }
}


